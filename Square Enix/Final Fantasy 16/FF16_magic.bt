//------------------------------------------------
//--- 010 Editor v15.0 Binary Template
//
//      File: FF16 Magic File (chara/<code>/magic/<code>.magic within chara/<code>/pack)
//   Authors: Nenkai, mThund3R
//   Version: 
//   Purpose: Check comments below
//  Category: 
// File Mask: *.magic
//  ID Bytes: 
//   History: 
//------------------------------------------------

// Useful sigs:
// MagicFile::ProcessUnk(__int64 a1, FileFormatBase **a2, char a3): 48 8B C4 48 89 58 ? 55 56 57 41 54 41 55 41 56 41 57 48 8D 68 ? 48 81 EC ? ? ? ? C5 F8 29 70 ? 48 8B 05 ? ? ? ? 48 33 C4 48 89 45 ? 45 33 F6 48 89 55
// MagicFile::GetSubEntryMaybe: 4C 8B 19 45 33 C9
// MagicFile::HasUnkSubDataEntry(__int64 subEntriesOffset, MagicFileSubEntryResult *result): 48 8B C4 48 89 58 ? 48 89 68 ? 48 89 70 ? 48 89 48 ? 57 48 8B 0A
// MagicFile::HandleSubEntry: 40 55 53 56 57 41 54 41 56 41 57 48 8B EC 48 83 EC ? 48 8D 59

typedef struct
{
    float X;
    float Y;
} Vec2 <read=Str("<%f, %f>", X, Y)>;

typedef struct
{
    float X;
    float Y;
    float Z;   
} Vec3 <read=Str("<%f, %f, %f>", X, Y, Z)>;

/*
It seems to contain a set of magic spells (basically blueprints that can be instantiated into spells) 
that can be used by characters. Each character has their own file which is different and 
two spells can have the same Id and yet be different, as long as they're contained in two different characters' files.

It seems like these spell "blueprints" are divided into lists, which are then divided 
into operations each containing a number of properties. Every property has a type and data (usually 4byte int or float)
that represents different things based on the type. Operations have a type too, but I still haven't noticed any patterns with those.
Basically properties just sets up an operation's parameter.

My guess is magic spells are instances of these spell objects / blueprints, 
and I'm pretty sure the magic file contains data for spell size, velocity, direction, VFXAudio, attackparam etc.

Instances of spells are basically any attack that's not connected to any bnpc
Which makes them unrelated to the character's collision files
They're like volatile npcs with their own collision, movement 

I even noticed some spells upon spawning cause the camera to zoom out, such as the behemoth comet spell
*/

// Used to determine whether I (nenkai) went into IDA to check the range of properties supported by a given operation
int DEBUG_KnowSupportedPropertiesForGroupType(int gType)
{
    return gType == 1 || gType == 25 || gType == 35 || gType == 39 || gType == 40 || gType == 50 || gType == 51 || gType == 87 || gType == 92 ||
        gType == 94 || gType == 109 || gType == 128 || gType == 182 || gType == 788 || gType == 1562 || gType == 1587 || gType == 1825 || 
        gType == 1841 || gType == 1842 || gType == 2325 || gType == 2493 || gType == 2592 || 
        gType == 2855 || gType == 3433 || gType == 3436 || gType == 3643 || gType == 3771 || gType == 3910 || gType == 3790 || gType == 3847 || 
        gType == 4446 || gType == 4448 || gType == 4516 || gType == 4553 || gType == 5722 || gType == 6460 || gType == 6473 || gType == 6453 ||
        gType == 6931 || gType == 6942 || gType == 7584 || gType == 7771 || gType == 7808;
}

typedef enum <uint>
{   
    // This is the full list of operations, hardcoded from executable, extracted here.
    // Operation list is complete. Supported properties per operation isn't completely extracted yet!
    // Some property ids may be off (because the game's compiler turned switch tables into annoying branches, making enums annoying to recover)
    
    // A distinct object (with a vtable) is created for each group at runtime.
    
    // The ids might look weird unlike say timeline type ids, but it's correct. 
    // ALSO, It seems both operations and properties use the same enum (no property will have the same id as an operation)
    
    //////////////////////////////////////////////////////////////////////////////////
    // Type ------------------- | Supported property ids
    // NOTE: property 2 seems to be a global property
    
    Operation_1 = 1,           // 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22 ,23, 24 or 25, 
                               // 1269, 2211, 2286, 2341, 2358, 2846, 3513, 3514, 3544, 3605, 3606, 3722, 4094, 4101, 4102, 4128, 5644, 6775, 6776, 6825, 6826, 6988
                               
    Operation_25 = 25,         // 24, 27, 28, 29, 30, 31, 33, 34, 81, 1231, 2359, 2799, 2800, 3772, 4101, 4102, 4243, 4244, 5959, 6056, 7813
    Operation_35 = 35,         // 35, 36, 37, 38, 1379
    Operation_39 = 39,         // 39, 1503, 4785
    Operation_40 = 40,         // 2 (?), 32, 35, 41, 42, 43, 44, 45, 46, 47, 48, 49, 1123, 2227, 2413, 2414, 2430, 4131, 4132, 5274, 5275, 5276, 6800, 6801, 6822
    Operation_50 = 50,         // Based on operation group 40
                               
    Operation_51 = 51,         // 12, 14, 26, 32, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
                               // 68, 69, 70, 71, 72, 73, 74, 76, 77, 78, 79, 80, 81, 82, 84, 85,
                               // 114, 185, 1102, 1286, 1433, 1434, 1458, 1484, 1657 (verify), 2396, 2397, 3916, 3938, 
                               // 4010, 4011, 4101, 4102, 4103, 4136, 4142, 4144, 5119, 5945, 5947, 6383, 6596, 
                               // 6600, 6913, 6975, 7037, 7186, 7200, 7811
    Operation_86 = 86,         
    Operation_87 = 87,         // 31, 34, 53, 89, 90, 91, 1954, 2359, 4101, 4102
    Operation_92 = 92,         // 26, 32, 39, 70, 74, 75, 76, 93, 1791, 3721, 3747, 6745, 7535, 7536, 7537, 7538, 7539, 7540, 7541, 7542, 7543, 
    Operation_94 = 94,         // 95, 96, 97, 98, 99, 1432, 1833, 1835, 1957, 4327, 4343, 4387, 4785, 4786, 5671, 6137, 7099, 7231, 
    Operation_100 = 100,       
    Operation_101 = 101,       
    Operation_103 = 103,       
    Operation_108 = 108,       
    Operation_109 = 109,       // 110, 4402, 4774, 6107
    Operation_111 = 111,       
    Operation_116 = 116,       
    Operation_121 = 121,       
    Operation_128 = 128,       // 129 (? not read?), 132, 140, 141, 147, 179, 201, 61, 262, 263, 3907, 4277, 6723, 6781, 6782, 7046, 7047
    Operation_133 = 133,
    Operation_135 = 135,
    Operation_137 = 137,
    Operation_138 = 138,
    Operation_139 = 139,
    Operation_141 = 141,
    Operation_144 = 144,
    Operation_151 = 151,
    Operation_153 = 153,
    Operation_157 = 157,
    Operation_169 = 169,
    Operation_171 = 171,
    Operation_182 = 182,       // 134, 136, 3785, 3802, 6179, 6184
    Operation_183 = 183,       
    Operation_186 = 186,       
    Operation_189 = 189,       
                               
    Operation_788 = 788,       // 29, 41, 42, 69, 73, 81, 105, 997, 1025, 1026, 1490, 1807, 1959, 1994, 1997, 1999, 2000, 2259, 2260, 2319, 2528, 2529, 2604, 2672, 3078, 
                               // 3079, 3362, 3363, 3440, 3658, 3659, 3681, 3872, 3906, 3961, 3962, 3970, 4131, 4132, 4427, 4509, 4829, 5101, 5125, 
                               // 5274, 5275, 5312, 6299, 6376, 7028, 7121, 7428, 7429, 7430, 7807
    Operation_798 = 798,       
    Operation_990 = 990,       
    Operation_1470 = 1470,     
    Operation_1562 = 1562,     // Based on operation group as 5722
    Operation_1587 = 1587,     // 1433, 2906, 4101, 4102, 4278, 4383, 15, 24, 26, 32, 64, 65, 66, 1286
    Operation_1623 = 1623,     
    Operation_1685 = 1685,     
    Operation_1825 = 1825,     // 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 3791, 5989, 6454, 7799
    Operation_1841 = 1841,     // Based on operation group as 5722, plus property 2575
    Operation_1842 = 1842,     // Based on operation group as 5722, plus property 2575
    Operation_2325 = 2325,     // 32, 35, 47, 48, 75, 93, 147, 148, 149, 150, 2413, 2414, 3850, 3909
    Operation_2366 = 2366,     
    Operation_2493 = 2493,     // 3, 8, 187, 2351, 2430, 2593, 3145, 7691, 7734, 7735
    Operation_2592 = 2592,     // 42, 43, 102, 148, 149, 150, 1686, 1688, 1793
    Operation_2598 = 2598,     
    Operation_2855 = 2855,     // 15, 16, 23, 79, 80, 185, 2856, 2857, 2858, 2859, 2860, 2977, 2978, 3170, 3495, 3498, 3499, 4002, 4014, 5841
    Operation_3070 = 3070,     
    Operation_3176 = 3176,     
    Operation_3270 = 3270,     
    Operation_3294 = 3294,     
    Operation_3391 = 3391,     
    Operation_3433 = 3433,     // 3434, 3440, 3441, 3608, 3610, 3691, 3692, 3693, 5142, 5685, 5799
    Operation_3436 = 3436,     // 102
    Operation_3515 = 3515,     
    Operation_3586 = 3586,     
    Operation_3558 = 3558,     
    Operation_3643 = 3643,     // 8, 32, 35, 42, 47, 68, 74, 75 or 76, 81, 102, 117, 2060, 4107, 4436, 6287, 6459, 6831
    Operation_3660 = 3660,     
    Operation_3771 = 3771,     // 3, 4, 5, 8, 37, 74, 75, 117, 3440, 3441, 3608, 6339, 6340, 6471, 6515, 6516
    Operation_3781 = 3781,     
    Operation_3790 = 3790,     // 8, 37, 96, 105, 1833, 2593, 3440
    Operation_3847 = 3847,     // 28, 30, 42, 3848, 3856, 4008, 4845, 4846, 4847, 4848
    Operation_3877 = 3877,     
    Operation_3910 = 3910,     // 26, 75, 117, 3911, 3912
    Operation_3940 = 3940,     
    Operation_3941 = 3941,     
    Operation_4015 = 4015,     
    Operation_4106 = 4106,     
    Operation_4274 = 4274,     
    Operation_4344 = 4344,     
    Operation_4446 = 4446,     // Based on operation 1841, + property 4447
    Operation_4448 = 4448,     // Based on operation 40
    Operation_4516 = 4516,     // 147
    Operation_4553 = 4553,     // 42
    Operation_4784 = 4784,     
    Operation_4828 = 4828,     
    Operation_4998 = 4998,     
    Operation_5027 = 5027,     
    Operation_5035 = 5035,     
    Operation_5059 = 5059,     
    Operation_5068 = 5068,     
    Operation_5133 = 5133,     
    Operation_5224 = 5224,     
    Operation_5231 = 5231,     
    Operation_5321 = 5321,     
    Operation_5476 = 5476,     
    Operation_5643 = 5643,     
    Operation_5722 = 5722,     // 32, 42, 43, 44, 45, 46, 47, 48, 49, 114, 2430
    Operation_5964 = 5964,     
    Operation_6024 = 6024,     
    Operation_6118 = 6118,     
    Operation_6264 = 6264,     
    Operation_6453 = 6453,     // 12, 4101, 4102
    Operation_6460 = 6460,     // Based on operation 35, minus property 6459
    Operation_6473 = 6473,     // 5276, 6474, 6475
    Operation_6846 = 6846,     
    Operation_6931 = 6931,     // 12, 42, 75, 102, 4101, 4102, 5838
    Operation_6942 = 6942,     // 41, 42, 81, 105, 997, 3078, 3079, 3362, 6299,
    Operation_7038 = 7038,     
    Operation_7187 = 7187,     
    Operation_7292 = 7292,     
    Operation_7378 = 7378,     
    Operation_7453 = 7453,     
    Operation_7481 = 7481,     
    Operation_7584 = 7584,     // 5274, 5275, 7585, 7586, 7587, 7588, 7812, 12, 42, 47, 74, 117, 4101, 4102, 
    Operation_7732 = 7732,     
    Operation_7771 = 7771,     // 12, 117, 4101, 4102
    Operation_7801 = 7801,     
    Operation_7808 = 7808,     // 4101, 4102, 7809
} OperationType;

typedef struct
{
    // Also handled differently.
    // i.e for OperationType = 4448
    // Refer to 48 89 5C 24 ? 48 89 74 24 ? 57 48 83 EC ? B8 ? ? ? ? C5 F8 29 74 24 for types
    // (this is a method for object 4448, refer to xref of that function for the relevant vtable)
    enum <int>
    {
        Property26_OperationGroupId = 26,   
        Property35_ProjectileDuration = 35,  
        Property35_ProjectileDurationRandomRange = 36,  
        Property37_OperationGroupId = 37,   
        Property41_AttackParamId = 41,   
        Property95_OperationGroupId = 95,   
        Property1379_ProjectileDurationDiffScaled = 1379,   
    } PropertyType;
    int DataSize <format=hex>;
    
    union
    {
        byte ValueBytes[DataSize] <bgcolor=cBlack>;
        switch (PropertyType)
        {
            case 2: int Value; break;
            case 3: float Value; break;
            case 4: float Value; break;
            case 5: float Value; break;
            case 6: float Value; break;
            case 7: int Value; break;
            case 8: float Value; break;
            case 9: float Value; break;
            case 10: float Chance; break;
            case 11: float Value; break;
            case 12: float Value; break;
            case 13: byte BoolValue; break;
            case 14: float Value; break;
            case 16: byte BoolValue; break;
            case 17: int Value; break;
            case 18: byte BoolValue; break;
            case 19: byte BoolValue; break;
            case 22: int Value; break;
            case 24: byte Value; break;
            case 26: int OperationGroupId; break;
            case 27: int VFXAudioId; break;
            case 28: int Value; break;
            case 29: int Value; break;
            case 30: byte BoolValue; break;
            case 31: float VFXAudioSizeFloat; break;
            case 32: float Value; break; // May also be a vec3?
            case 35: float ProjectileDuration; break;
            case 36: Vec3 ProjectileRandDurationMinMax; break;
            case 37: int OperationGroupId; break; // ref: 8B 93 ? ? ? ? 85 D2 74 ? 48 8B 4B ? E8 ? ? ? ? 83 A3 ? ? ? ? ? 83 A3 ? ? ? ? ? 83 A3 & more (op 3771)
            case 38: byte BoolValue; break;
            case 39: int OperationGroupId; break; // ref: 44 8B 49 ? 33 F6 48 8B D9 45 85 C9 0F 84 ? ? ? ? 48 8B 51 ? 48 8D 05 ? ? ? ? C5 FB 10 05 ? ? ? ? 48 89 44 24 ? 48 8D 4C 24 ? 8B 05 ? ? ? ? 8B BA
            case 41: int AttackParamId; break;
            
            case 42: float Value; break; // These three are as a group
            case 43: float Rate; break; // Speed
            case 44: float Target; break;
            
            case 45: int Type; break; // 41 8B 88 ? ? ? ? 85 C9 0F 84
            case 46: float Value; break;
            case 47: float Value; break;
            case 48: float Value; break;
            case 49: float Value; break;
            case 52: Vec3 Value; break;
            case 53: Vec3 Value; break;
            case 54: Vec3 Value; break;
            case 55: Vec3 Value; break;
            case 56: Vec3 Value; break;
            case 57: Vec3 Value; break;
            case 58: Vec3 Value; break;
            case 59: Vec3 Value; break;
            case 60: Vec3 Value; break;
            case 61: Vec3 Value; break;
            case 62: Vec3 Value; break;
            case 63: Vec3 Value; break;
            case 64: Vec3 Value; break;
            case 65: int Value; break;
            case 66: float Value; break;
            case 68: int Value; break;
            case 69: int Value; break;
            case 70: float Value; break;
            case 71: float Value; break;
            case 72: Vec3 Value; break;
            case 73: int Value; break;
            case 74: float Value; break;
            case 75: int Value; break;
            case 76: int Value; break;
            case 77: int Value; break;
            case 78: int Value; break;
            case 79: int Value; break;
            case 80: int Value; break;
            case 81: uint EidId; break; // ref: 8B 97 ? ? ? ? 4C 8D 45 ? 48 8B C8
            case 89: int VfxAudioId; break; // ref: 44 8B 47 ? 44 8A 67
            case 90: byte BoolValue; break; // Whether to use property 91
            case 91: int Value; break; // MotionLayerSetId maybe? not sure
            case 93: float Value; break;
            case 95: int OperationGroupId; break;
            case 96: int OperationGroupId; break; // ref: E8 ? ? ? ? 83 A3 ? ? ? ? ? 83 A3 ? ? ? ? ? C6 83 ? ? ? ? ? EB
            case 97: int Value; break;
            case 98: int Value; break;
            case 99: int Value; break;
            case 102: int OperationGroupId; break; // ref: 48 89 5C 24 ? 48 89 74 24 ? 57 48 83 EC ? 40 8A FA 48 8B D9 8B 91
            case 105: int VFXAudioId; break; // ref: 44 8B 81 ? ? ? ? 48 8B F9 45 85 C0 74
            case 109: int Value; break;
            case 110: int OperationGroupId; break;
            case 114: byte BoolValue; break;
            case 117: float Value; break;
            case 129: float Value; break;
            case 134: int Value; break;
            case 136: int Value; break;
            case 147: int MagicId; break; // ref: 44 8B 41 ? 8B 89
            case 148: int MagicId; break; // ref: 44 8B 43 ? 48 8B 53 ? 48 8D 4C 24
            case 149: int MagicId; break; // ref: 44 8B 43 ? EB ? 3B 4B
            case 150: int Value; break;
            case 187: int Value; break;
            case 997: float Value; break;
            case 1025: byte Value; break;
            case 1026: byte Value; break;
            case 1123: byte BoolValue; break;
            case 1231: int Value; break;
            case 1232: int Value; break;
            case 1379: float ProjectileDuration; break; // Same as 35, but DifficultyLevel->Unk11 * this
            case 1432: int Value; break;
            case 1484: float Value; break;
            case 1490: byte Value; break;
            case 1503: int OperationGroupId; break; // ref: E8 ? ? ? ? 48 8B 0D ? ? ? ? 48 8D 54 24 ? E8 ? ? ? ? 89 73
            case 1686: float Value; break;
            case 1688: float Value; break;
            case 1791: int Value; break;
            case 1793: float Value; break;
            case 1807: Vec3 Value; break;
            case 1833: int OperationGroupId; break; // 8B 97 ? ? ? ? 85 D2 74 ? 48 8B 4F ? E8 ? ? ? ? 83 A7
            case 1957: byte BoolValue; break;
            case 1994: byte Value; break;
            case 1997: Vec3 Value; break;
            case 1999: float Angle; break;
            case 2000: float Angle; break;
            case 2060: float Value; break;
            case 2061: uint Value; break;
            case 2062: uint Value; break;
            case 2063: uint Value; break;
            case 2064: uint Value; break;
            case 2065: uint Value; break;
            case 2066: uint Value; break;
            case 2067: uint Value; break;
            case 2068: uint Value; break;
            case 2069: uint Value; break;
            case 2211: float Value; break;
            case 2227: byte BoolValue; break;
            case 2259: byte Value; break;
            case 2260: byte Value; break;
            case 2319: int Value; break;
            case 2351: float Value; break;
            case 2359: byte BoolValue; break;
            case 2396: int LayoutInstanceId; break;
            case 2413: int Value; break;
            case 2414: int Value; break;
            case 2430: Vec3 Rotation; break;
            case 2528: int Value; break;
            case 2529: int Value; break;
            case 2593: float Value; break;
            case 2575: int Value; break;
            case 2604: byte Value; break;
            case 2672: byte Value; break;
            case 2798: int Value; break;
            case 2856: byte BoolValue; break;
            case 2857: float Value; break;
            case 2906: byte Value; break;
            case 3078: int Value; break;
            case 3079: int Value; break;
            case 3171: float Value; break;
            case 3172: float Value; break;
            case 3362: float Value; break;
            case 3363: int Value; break;
            case 3434: int Value; break;
            case 3440: int OperationGroupId; break;
            case 3441: int OperationGroupId; break;
            case 3497: Vec3 Value; break;
            case 3498: Vec3 Value; break;
            case 3606: byte BoolValue; break;
            case 3608: int OperationGroupId; break;
            case 3609: int OperationGroupId; break;
            case 3658: byte Value; break;
            case 3659: int Value; break;
            case 3691: int OperationGroupId; break;
            case 3692: int OperationGroupId; break;
            case 3693: int OperationGroupId; break;
            case 3721: byte BoolValue; break;
            case 3722: int Value; break;
            case 3785: int Value; break;
            case 3791: int Value; break;
            case 3802: int Value; break;
            case 3848: uint CameraFCurveId; break; // ref: 8B 53 ? 48 8B C8 E8 ? ? ? ? 4C 8B C0 48 85 C0 74 ? 48 83 38 ? 7C ? 48 8B C8 E8 ? ? ? ? 48 85 C0 74 ? 49 83 38 ? 7C ? 49 8B C8 E8 ? ? ? ? EB ? 48 8B C7
            case 3850: uint CameraFCurveId; break; // ref: 8B 53 ? C4 C1 78 28 D9
            case 3856: uint CameraFCurveId; break; // ref: 8B 53 ? 48 8B C8 E8 ? ? ? ? 4C 8B C0 48 85 C0 74 ? 48 83 38 ? 7C ? 48 8B C8 E8 ? ? ? ? 48 85 C0 74 ? 49 83 38 ? 7C ? 49 8B C8 E8 ? ? ? ? 48 8B F8
            case 3938: int LayoutInstanceId; break;
            case 3961: int Value; break;
            case 3962: int Value; break;
            case 3681: byte Value; break;
            case 3872: byte Value; break;
            case 3906: int Value; break;
            case 3907: float Value; break;
            case 3970: byte Value; break;
            case 4002: int EidId; break;
            case 4007: float Value; break;
            case 4008: float Time; break; // ref: C5 FA 10 61 ? C5 FA 10 2D
            case 4010: float Value; break;
            case 4011: int Value; break;
            case 4014: Vec3 Value; break;
            case 4101: float Value; break; // ref: C5 BA 58 77
            case 4102: float Value; break; // ref: C5 BA 58 77
            case 4107: int Value; break;
            case 4131: int Value; break;
            case 4132: int Value; break;
            case 4243: byte BoolValue; break;
            case 4278: int Value; break;
            case 4279: int Value; break;
            case 4327: int Value; break;
            case 4343: int Value; break;
            case 4387: byte BoolValue; break;
            case 4402: int OperationGroupId; break;
            case 4427: byte Value; break;
            case 4436: int Value; break;
            case 4447: uint Value; break;
            case 4509: byte Value; break;
            case 4774: int OperationGroupId; break;
            case 4785: byte BoolValue; break;
            case 4829: byte Value; break;
            case 4845: int Value; break;
            
            case 4846: int Value; break; // Group of 3 - ref: 48 83 C1 ? E8 ? ? ? ? F6 43 ? ? 0F 85
            case 4847: int Rate; break;
            case 4848: int Target; break;
            
            case 5101: byte Value; break;
            case 5125: byte Value; break;
            case 5274: int CommandId; break;
            case 5275: int CommandId; break;
            case 5276: int SkillUpgradeLevel; break; // ref: 3B 46 ? B9
            case 5312: byte Value; break;
            case 5644: Vec3 Value; break;
            case 5671: int Value; break;
            case 5685: int Value; break;
            case 5838: float Value; break;
            case 5989: int Value; break;
            case 6056: byte BoolValue; break;
            case 6107: int OperationGroupId; break;
            case 6179: int Value; break;
            case 6287: float Value; break;
            case 6299: int Value; break;
            case 6339: byte Value; break;
            case 6340: byte Value; break;
            case 6376: byte Value; break;
            case 6383: byte BoolValue; break;
            case 6454: byte Value; break;
            case 6459: byte Value; break;
            case 6471: int Value; break;
            case 6474: int OperationGroupId; break; // ref: 8B 54 9E ? E8 ? ? ? ? 48 8B 5C 24
            case 6475: int OperationGroupId; break; // ref: 8B 54 9E ? E8 ? ? ? ? 48 8B 5C 24
            case 6471: int Value; break;
            case 6515: int OperationGroupId; break; // ref: 8B 93 ? ? ? ? 85 D2 74 ? 48 8B 4B ? E8 ? ? ? ? 83 A3 ? ? ? ? ? C6 83
            case 6516: int OperationGroupId; break; // ref: 8B 93 ? ? ? ? 85 D2 74 ? 48 8B 4B ? E8 ? ? ? ? 83 A3 ? ? ? ? ? EB
            case 6596: byte BoolValue; break;
            case 6600: float Value; break;
            case 6775: float Chance; break;
            case 6776: byte BoolValue; break;
            case 6800: int Value; break;
            case 6801: int Value; break;
            case 6822: int Value; break;
            case 6825: byte BoolValue; break;
            case 6826: byte BoolValue; break;
            case 6831: float Value; break;
            case 6913: int Value; break;
            case 6975: int Value; break;
            case 6988: byte BoolValue; break;
            case 7028: byte Value; break;
            case 7037: float Value; break;
            case 7121: byte Value; break;
            case 7428: byte Value; break;
            case 7429: byte Value; break;
            case 7430: byte Value; break;
            case 7585: int Value; break;
            case 7586: int Value; break;
            case 7587: int Value; break;
            case 7588: int Value; break;
            case 7791: int Value; break;
            case 7799: byte BoolValue; break;
            case 7807: byte Value; break;
            case 7809: int Value; break;
            case 7811: byte BoolValue; break;
            case 7812: int Value; break;
            case 7813: byte BoolValue; break;
            default:
                Printf("Unsupported property type %d for operation %d\n", PropertyType, OperationType_);  
                break; 
        }
    } Data;
} Property <read=Str("Type: %d", PropertyType), optimize=false, bgcolor=0x006688,
                comment="Sets an operation's property to the specified value">;

typedef struct
{
    int NumTotalProperties <comment="Across all operations">;
    local int op = 0;
    while (op < NumTotalProperties)
    {
        struct
        {
            // Appears to actually be some sort of engine type
            // Different class/object is initiated depending on this
            OperationType OperationType_;
            if (EnumToString(OperationType_) == "")
                Printf("Unrecognized operation %d\n", OperationType_);
                
            if (!DEBUG_KnowSupportedPropertiesForGroupType(OperationType_))
                Printf("NOTE: Operation %d's allowed properties aren't figured out yet\n", OperationType_);
                
            int PropertyCount;
            Property Property_[PropertyCount];
        } Operation <read=Str("Type: %d, Count: %d", OperationType_, PropertyCount),
            comment="Each operation does something different and supports a specified set of properties">;
        
        op += Operation.PropertyCount;
    }
} OperationList <bgcolor=cDkGreen, comment="There can only be up to 32 operations (fixed array)">;

typedef struct
{
    uint Id;
    int OperationListOffset <fgcolor=cRed, format=hex>;
    int OperationListSize <comment="Size of the struct specified by DataOffset", format=hex>;
    
    FSeek(startof(this) + OperationListOffset);
    OperationList OperationList_;
} OperationGroup <read=Str("ID: %d", Id), bgcolor=cGreen>;

typedef struct
{
    float field_0x00;
    if (MainHeader.Version >= 5)
        int Unk;
    
    struct
    {
        int OperationGroupCount;
        
        for (local int j = 0; j < OperationGroupCount; j++)
        {
            FSeek(startof(this) + 4 + (j * 0x0C));
            OperationGroup OperationGroup_ <bgcolor=cGreen>;
        }
    } OperationGroupList;
} OperationGroups;
       
typedef struct
{
    uint MagicId <fgcolor=cPurple, comment="Referenced by chara timelines or SummonMode">;
    int OperationGroupsOffset <fgcolor=cRed, format=hex>;
    int OperationGroupsDataSize <comment="Size of the struct specified by OperationGroupsOffset", format=hex>;
    
    FSeek(startof(this) + OperationGroupsOffset);
    OperationGroups OperationGroups_;
} Magic;
                     
struct
{
    struct
    {
        int Version;
        int NumSections;
    } MainHeader <bgcolor=cPurple>;
    
    // Note: The game does not use NumSections (other than check for not zero)
    // or even seem to split this 'sub-header' into multiple sections
    // We do here, for convenience.
    // Section 1 MUST exist as per code. Direct indexing
    struct
    {
        int Index;
        int Offset <format=hex, fgcolor=cRed>;
        int Size <format=hex>;
    } Sections[MainHeader.NumSections] <bgcolor=cDkPurple>;

    FSeek(startof(Sections[0]) + Sections[0].Offset);
    struct
    {
        int EntryCount <fgcolor=cGreen>;
        for (local int i = 0; i < EntryCount; i++)
        {
            FSeek(startof(EntryCount) + (i * 0x0C) + 4);
            Magic Magic_ <read=Str("Magic ID: %d", MagicId), bgcolor=cBlue>;
        }
    } MainSectionData <open=true>;
    
    FSeek(startof(Sections[1]) + Sections[1].Offset);
    byte Section1Data[Sections[1].Size];
} MagicFile <open=true>;
