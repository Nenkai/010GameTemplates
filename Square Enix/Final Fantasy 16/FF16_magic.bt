//------------------------------------------------
//--- 010 Editor v15.0 Binary Template
//
//      File: FF16 Magic File (chara/<code>/magic/<code>.magic within chara/<code>/pack)
//   Authors: Nenkai, mThund3R
//   Version: 
//   Purpose: Check comments below
//  Category: 
// File Mask: *.magic
//  ID Bytes: 
//   History: 
//------------------------------------------------

// Useful sigs:
// MagicFile::ProcessUnk(__int64 a1, FileFormatBase **a2, char a3): 48 8B C4 48 89 58 ? 55 56 57 41 54 41 55 41 56 41 57 48 8D 68 ? 48 81 EC ? ? ? ? C5 F8 29 70 ? 48 8B 05 ? ? ? ? 48 33 C4 48 89 45 ? 45 33 F6 48 89 55
// MagicFile::GetSubEntryMaybe: 4C 8B 19 45 33 C9
// MagicFile::HasUnkSubDataEntry(__int64 subEntriesOffset, MagicFileSubEntryResult *result): 48 8B C4 48 89 58 ? 48 89 68 ? 48 89 70 ? 48 89 48 ? 57 48 8B 0A
// MagicFile::HandleSubEntry: 40 55 53 56 57 41 54 41 56 41 57 48 8B EC 48 83 EC ? 48 8D 59

typedef struct
{
    float X;
    float Y;
} Vec2 <read=Str("<%f, %f>", X, Y)>;

typedef struct
{
    float X;
    float Y;
    float Z;   
} Vec3 <read=Str("<%f, %f, %f>", X, Y, Z)>;

/*
It seems to contain a set of magic spells (basically blueprints that can be instantiated into spells) 
that can be used by characters. Each character has their own file which is different and 
two spells can have the same Id and yet be different, as long as they're contained in two different characters' files.

It seems like these spell "blueprints" are divided into lists, which are then divided 
into operations each containing a number of properties. Every property has a type and data (usually 4byte int or float)
that represents different things based on the type. Operations have a type too, but I still haven't noticed any patterns with those.
Basically properties just sets up an operation's parameter.

My guess is magic spells are instances of these spell objects / blueprints, 
and I'm pretty sure the magic file contains data for spell size, velocity, direction, VFXAudio, attackparam etc.

Instances of spells are basically any attack that's not connected to any bnpc
Which makes them unrelated to the character's collision files
They're like volatile npcs with their own collision, movement 

I even noticed some spells upon spawning cause the camera to zoom out, such as the behemoth comet spell
*/

typedef enum <uint>
{   
    // This is the full list of operations, hardcoded from executable, extracted here.
    // Operation list is complete. Supported properties per operation isn't completely extracted yet!
    // Some property ids may be off (because the game's compiler turned switch tables into annoying branches, making enums annoying to recover)
    
    // A distinct object (with a vtable) is created for each group at runtime.
    
    // The ids might look weird unlike say timeline type ids, but it's correct. 
    // ALSO, It seems both operations and properties use the same enum (no property will have the same id as an operation)
    
    //////////////////////////////////////////////////////////////////////////////////
    // NOTE: property 2 seems to be a global property
    // NOTE 2: * = unused in vanilla
    
    // Type -------------------------------- | Supported property ids
    // Sets projectile scale, speed, etc.
    Operation_1_SetupProjAspects = 1,        // 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22 ,23, 24,
                                             // 1269*, 2211, 2286, 2351, 2368, 2856, 3513, 3514, 3544, 3605, 3606, 3722, 4094, 4101, 4102, 4128, 5644, 6775*, 6776, 6825, 6826, 6988
                                             
    // Sets projectile VFX.
    Operation_25_SetupProjVFX = 25,          // 24*, 27, 28, 29, 30, 31, 33, 34, 81, 1231, 2359, 2798, 2799, 3772*, 4101, 4102*, 4243, 4244, 5959, 6056, 7791*, 7813
    
    // Sets the projectile's lifetime
    Operation_35_SetupProjLifetime = 35,     // 35, 36, 37, 38, 1417
    
    Operation_39 = 39,                       // 39, 1503, 4785
    
    // Sets the projectile's attack and hitbox?
    Operation_40_SetupProjHitboxAttack = 40, // 32, 35, 41, 42, 43, 44, 45, 46, 47, 48, 49, 1123, 2227, 2413*, 2414*, 2430, 4131*, 4132, 5274, 5275, 5276*, 6800*, 6801*, 6822*
    
    Operation_50 = 50,                       // Based on operation group 40
    
    // Initializes
    Operation_51_Initialize = 51,            // 12, 14, 26, 32, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
                                             // 68, 69, 70, 71, 72, 73, 74, 76, 77, 78, 79, 80, 81, 82, 84, 85,
                                             // 114, 185, 1102, 1286, 1433, 1434, 1458, 1484, 1657, 2396, 2397, 3916, 3938, 
                                             // 4010, 4011, 4101, 4102, 4103, 4136, 4142, 4144, 5119, 5945, 5947*, 6383, 6596, 
                                             // 6600, 6913, 6975*, 7037, 7186*, 7200*, 7811
                                             
    Operation_86 = 86,                       // 26, 74*, 75*, 76*, 84
    
    // Creates a VFX at the source actor
    // It doesn't work well with all vfx though, since some vfx don't have a well 
    // defined lifetime (they're gone only with conditions, so like, target hit, or projectile has a duration defined in the magic)
    Operation_87_SourceVFX = 87,            // 31, 34, 53, 89, 90*, 91*, 1954*, 2359, 4101*, 4102
    
    Operation_92 = 92,                      // 26*, 32*, 39, 70, 74, 75, 76, 93, 1791, 3721, 3746, 3747, 6745, 7535*, 7536*, 7537*, 7538*, 7539*, 7540*, 7541*, 7542*, 7543*
    
    // Sets a callback operation group on target hit
    Operation_94_OnTargetHit = 94,          // 95, 96, 97, 98, 99, 1432, 1833, 1835, 1957, 4327, 4343, 4387, 4785, 4786, 5671, 6137, 7099, 7231
    
    Operation_100 = 100,                    // Operation not used in vanilla! 41* (int)
    Operation_101 = 101,                    // 102 (int) 
    Operation_103 = 103,                    // Operation not used in vanilla! 41*, 42*, 105*, 106*, 107*
    Operation_108 = 108,                    // 3, 6, 8, 9, 11, 47
    Operation_109 = 109,                    // 110, 4402, 4774, 6107
    Operation_111 = 111,                    // 31, 112, 113, 114
    Operation_116 = 116,                    // Operation not used in vanilla! 8*, 93*, 117*, 118*, 119*, 120*
    Operation_121 = 121,                    // Operation not used in vanilla! 8*, 102*, 122*, 123*, 124*, 125*, 126*, 127* (all 4 bytes)
    Operation_128 = 128,                    // 8, 9*, 15, 47, 69, 129, 130, 131, 132, 3907, 4277, 6723*, 6781*, 6782*, 7046*, 7047*
    Operation_133 = 133,                    // Operation not used in vanilla! 134*
    Operation_135 = 135,                    // 70, 114, 134, 136, 1341, 1649, 2153, 2311, 2420, 2430*, 3764*, 4135, 4258, 4259, 4260, 4261, 5642*, 5947, 6170, 6685*, 7366*, 7711*, 7712*, 7733*, 7757*
    Operation_137 = 137,                    // Operation not used in vanilla! 41*, 42*, 117*
    Operation_138 = 138,                    // Operation not used in vanilla! Based on operation 101
    Operation_139 = 139,                    // 23, 42, 43, 44*, 114, 140, 3349, 4128
    Operation_141 = 141,                    // Operation not used in vanilla! 75*, 102*, 142*, 143*
    Operation_144 = 144,                    // 14, 23, 26, 42, 74, 75, 81, 145
    Operation_151 = 151,                    // 48*, 74, 75, 93, 102, 152*
    Operation_153 = 153,                    // 32, 65, 74, 75, 102, 2919, 2920, 2921
    Operation_157 = 157,                    // Operation not used in vanilla! 8*, 81*, 147*, 148*, 149*, 158*, 159*
    Operation_169 = 169,                    // Operation not used in vanilla! 42*, 75*, 102*, 2764*
    Operation_171 = 171,                    // 8, 9, 10, 11, 23, 24*, 145, 172, 173*, 174*, 175, 176*, 177*, 178*, 179*, 180*, 181*, 1793, 1794, 1796, 2028*, 4003*, 4060, 4128, 4296
    Operation_182 = 182,                    // 134, 136, 3785, 3802, 6179, 6184
    Operation_183 = 183,                    // 26, 81, 84*, 85*, 186*
    Operation_186 = 186,                    // Operation not used in vanilla! 105*, 117*, 187*, 188*
    Operation_189 = 189,                    // Operation not used in vanilla! 190*, 191*, 192*, 193*
                               
    Operation_788 = 788,                    // 29, 41, 42, 69, 73, 81, 105, 997, 1025, 1026, 1490, 1807, 1959, 1994, 1997, 1999, 2000, 2259, 2260, 2319, 2528, 2529, 2604*, 2672*, 3078, 
                                            // 3079, 3362, 3363, 3440*, 3658, 3659, 3681, 3872, 3906, 3961*, 3962*, 3970, 4131*, 4132, 4427, 4509, 4829, 5101*, 5125, 
                                            // 5274, 5275, 5312*, 6299, 6376, 7028*, 7121, 7428*, 7429*, 7430*, 7807*

    Operation_798 = 798,                    // 110, 188
    Operation_990 = 990,                    // Operation not used in vanilla! 104*, 105*, 147*, 159*, 994*, 995*
    Operation_1470 = 1470,                  // 8, 9, 11, 47*, 93, 188, 1063*
    Operation_1562 = 1562,                  // 32*, 42, 43*, 44*, 45*, 46*, 47*, 48*, 49*, 114, 2430*
    Operation_1587 = 1587,                  // 15, 24, 26, 32, 64*, 65*, 66, 1286, 1433, 2906, 4101*, 4102, 4278, 4279, 4383*
    Operation_1623 = 1623,                  // 8, 81*, 1818, 6270, 6271, 6272, 6273, 6274, 6275  
    Operation_1685 = 1685,                  // 8*, 9*, 11*, 18*, 32, 42, 43, 114*, 1686*, 1687*, 1688, 1689*, 1690*, 1697*, 1698*, 1704*
    Operation_1825 = 1825,                  // 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 3791, 5989, 6454*, 7799
    Operation_1841 = 1841,                  // Based on operation 1562, plus property 2575
    Operation_1842 = 1842,                  // Based on operation 1562, plus property 2575
    Operation_2325 = 2325,                  // 8, 32, 35, 47, 48, 75, 93, 147, 148, 149, 150, 2413, 2414, 3848, 3907
    Operation_2366 = 2366,                  // 81, 105, 1341, 2367
    Operation_2493 = 2493,                  // 3*, 8, 187, 2351, 2430, 2593, 3145*, 7691, 7734*, 7735*
    Operation_2592 = 2592,                  // 35, 42, 43, 102, 148, 149, 150, 1686, 1688, 1793
    Operation_2598 = 2598,                  // 102, 2599, 2630
    Operation_2855 = 2855,                  // 15, 16*, 23, 79, 80*, 185*, 2856*, 2857, 2858*, 2859, 2860, 2977*, 2978*, 2979*, 3170, 3495, 3497*, 3498, 3499, 4002, 4014, 5841, 7463*
    Operation_3070 = 3070,                  // 75, 117, 3077, 3113, 3114, 3115, 3116, 3694, 3695, 3696
    Operation_3176 = 3176,                  // 3176 (??), 4071, 7102
    Operation_3270 = 3270,                  // 8, 46, 102
    Operation_3294 = 3294,                  // 26, 31, 32, 132 
    Operation_3391 = 3391,                  // Operation not used in vanilla! 52*, 53*, 102*, 1458*
    Operation_3433 = 3433,                  // 3434, 3440, 3441, 3608, 3609, 3691, 3692, 3693, 5142, 5143, 5685, 5799
    Operation_3436 = 3436,                  // 102
    Operation_3515 = 3515,                  // 3, 8, 9, 11, 12, 28, 122, 123, 2413, 3903, 4008
    Operation_3558 = 3558,                  // Based on operation 139
    Operation_3586 = 3586,                  // 32, 46, 81, 102, 110, 148, 2599
    Operation_3643 = 3643,                  // 8, 32, 35, 42, 47, 68, 74, 75, 81, 102, 117, 2060, 4107, 4436, 6287, 6459, 6831
    Operation_3660 = 3660,                  // 32, 74, 102, 2318
    Operation_3771 = 3771,                  // 3, 4, 5, 8, 37, 74, 75, 117, 3440, 3441, 3608, 6339, 6340, 6471, 6515, 6516
    Operation_3781 = 3781,                  // 32, 42, 68, 74, 75, 132, 3782
    Operation_3790 = 3790,                  // 8, 37, 96, 105, 1833, 2593, 3440
    Operation_3847 = 3847,                  // 28, 30, 42, 3848, 3856, 4008, 4845, 4846, 4847, 4848
    Operation_3877 = 3877,                  // 3897, 3898, 3899, 3900, 3901
    Operation_3910 = 3910,                  // 26, 75*, 117, 3911*, 3912
    Operation_3940 = 3940,                  // Based on operation 3433, plus 75 & 5034 properties
    Operation_3941 = 3941,                  // 46, 4165
    Operation_4015 = 4015,                  // 18, 26, 32, 47, 48, 64, 69, 74, 75, 93*, 114*, 1484, 2430, 3499, 3544, 3721, 4010*, 4011*, 4614, 5120, 5904
    
    Operation_4106 = 4106,                  // 8, 9, 11, 23, 24, 41, 42, 43*, 46, 69, 81, 105, 1686*, 1688, 1689, 1690, 1999, 2259, 2260, 3431, 3432, 3659, 3681, 
                                            // 3782, 4107, 4128, 4262, 4263, 4282, 4291, 4293, 4294, 4295, 4297, 4298, 4442, 4443, 4540, 4832, 4833
    
    Operation_4274 = 4274,                  // 3113, 3114, 3115, 3116, 3694, 4275, 4276
    Operation_4344 = 4344,                  // 8, 12, 24, 32, 79, 81 (?, not in code?), 132, 1432, 1999, 2318*, 3078, 3606, 4277
    Operation_4446 = 4446,                  // Based on operation 1841, + property 4447
    Operation_4448 = 4448,                  // Based on operation 40
    Operation_4516 = 4516,                  // 147
    Operation_4553 = 4553,                  // 42
    Operation_4784 = 4784,                  // 8, 9, 11*, 24, 28, 30, 41, 42, 43, 52, 53, 75, 78, 81, 89, 102, 104, 105, 109, 132*, 148, 188, 995, 2060, 3432*, 3722, 3848, 3856, 4277, 4846
    Operation_4828 = 4828,                  // 8*, 20, 23, 24*, 30, 41, 42*, 52, 71, 89, 105, 106, 119, 132, 172, 187, 1123, 1490, 1688, 1689, 1690, 2060, 2856, 2857*, 3431, 3432*, 3659, 5747, 5932, 5958
    Operation_4998 = 4998,                  // 26, 42, 74, 75, 4999, 5000, 6115             
    Operation_5035 = 5035,                  // 35, 41, 42, 46, 49, 52, 53, 54, 3078, 3362, 5036, 5037, 5038, 5039, 5040, 5041
    Operation_5059 = 5059,                  // 35      
    Operation_5068 = 5068,                  // 3434, 3440, 3441, 3608, 3609, 3691, 3962*, 3963* 
    Operation_5133 = 5133,                  // 28*, 30*, 46, 48, 3848, 3856, 6135
    Operation_5207 = 5207,                  // 26, 42, 75
    Operation_5224 = 5224,                  // 42, 188
    Operation_5231 = 5231,                  // Operation not used in vanilla! 5232*, 5234*, 5235*, 5236*, 5237*, 5323*
    Operation_5321 = 5321,                  // 23, 26, 32, 73, 74, 75, 5322, 5324, 5325, 5326, 5327, 5355, 5356, 5525
    Operation_5476 = 5476,                  // 32, 93, 5838, 5839
    Operation_5643 = 5643,                  // 8, 9, 11, 41, 42, 44, 105, 3659, 5683, 5684, 6053, 6087, 6088, 6089, 6090, 6180
    Operation_5722 = 5722,                  // Based on operation 1562
    Operation_5964 = 5964,                  // 8, 9, 11, 23, 25, 32, 41, 42, 93, 109, 3659, 3782, 4999, 5000, 5970, 5971, 5972, 5973, 5974, 6087, 6088, 6203, 6204, 6257, 6276, 6277
    Operation_6024 = 6024,                  // 26, 74, 75, 117, 6050, 6208
    Operation_6118 = 6118,                  // 26, 42, 74, 75, 6119, 6120, 6121, 6122
    Operation_6264 = 6264,                  // 6265
    Operation_6453 = 6453,                  // 12, 4101, 4102
    Operation_6460 = 6460,                  // Based on operation 35, minus property 6459
    Operation_6473 = 6473,                  // 5276, 6474, 6475
    Operation_6846 = 6846,                  // 6851, 6925, 6926, 6927, 6928
    Operation_6931 = 6931,                  // 12, 42, 75, 102, 4101, 4102, 5838
    Operation_6942 = 6942,                  // 41, 42, 81, 105, 997, 3078, 3079*, 3362, 6299*
    Operation_7038 = 7038,                  // 1, 7039, 7040*, 7041*, 7042*
    Operation_7187 = 7187,                  // Operation not used in vanilla! 42*, 47*, 187*
    Operation_7292 = 7292,                  // Operation not used in vanilla! 42*, 43*, 44*, 49*, 7293*, 7294*, 7300*, 7610*
    Operation_7378 = 7378,                  // Operation not used in vanilla! 26*, 30*, 74*, 76*, 117*, 7379*, 7380*, 7411*, 7412
    Operation_7453 = 7453,                  // Operation not used in vanilla! Based on operation 3847
    Operation_7481 = 7481,                  // Operation not used in vanilla! 25*, 41*, 42*, 81*, 997*, 3659*, 6087*, 6088*, 6257*, 7480*, 7482*, 7483*, 7484*, 7485*, 7486*
    Operation_7584 = 7584,                  // 12, 42, 47, 74, 117, 4101, 4102, 5274, 5275, 7585, 7586, 7587, 7588, 7812
    Operation_7732 = 7732,                  // 47, 74
    Operation_7771 = 7771,                  // 12, 117, 4101, 4102
    Operation_7801 = 7801,                  // 2061, 2062, 2063, 2064, 2065, 2067, 2068, 2069, 3791, 5989, 6454
    Operation_7808 = 7808,                  // 4101, 4102, 7809
} OperationType;

typedef struct
{
    // Also handled differently.
    // i.e for OperationType = 4448
    // Refer to 48 89 5C 24 ? 48 89 74 24 ? 57 48 83 EC ? B8 ? ? ? ? C5 F8 29 74 24 for types
    // (this is a method for object 4448, refer to xref of that function for the relevant vtable)
    enum <int>
    {
        Property8_SpeedStart = 8,
        Property9_SpeedIncreaseRate = 9,
        Property10_SpeedStartRangeRand = 10,
        Property11_SpeedMax = 11,
        Property13_NoTrackingTarget = 13,
        Property14_UnkMaxAngleRad = 14,
        Property22_VerticalAngleDegreesOffset = 22,
        Property26_ExecOperationGroupId = 26,  
        Property27_VFXAudioId = 27,
        Property31_VFXScale = 31, 
        Property35_ProjectileDuration = 35,  
        Property36_ProjectileDurationRandomRange = 36,  
        Property37_OnNoImpactOperationGroupId = 37,   
        Property41_AttackParamId = 41,
        Property42_Hitbox_AttachmentSize = 42,
        Property73_TargetType = 73,
        Property81_SetupEid = 81,
        Property89_VFXAudioId = 89,
        Property95_OnTargetHitOperationGroupIdCallback = 95,   
        Property1379_ProjectileDurationDiffScaled = 1379,   
    } PropertyType;
    int DataSize <format=hex>;
    
    union
    {
        byte ValueBytes[DataSize] <bgcolor=cBlack>;
        switch (PropertyType)
        {
            case 2: int Value; break;
            
            // Grouped (animated scalar, value (3)/rate (4)/target (5)) - ref: 48 8B CE E8 ? ? ? ? C5 FA 10 06
            case 3: float AnimatedScalarValue; break;
            case 4: float AnimatedScalarRate; break;
            case 5: float AnimatedScalarTarget; break;
            
            case 6: float Value; break;
            case 7: float UnkDuration; break; // ref: C5 FA 11 87 ? ? ? ? 48 85 DB 74 ? 48 8B 03 48 8B CB FF 50 ? 4C 8D 9C 24 ? ? ? ? 49 8B 5B ? 49 8B 73 ? 49 8B 7B ? C4 C1 78 28 73 ? C4 C1 78 28 7B ? C4 41 78 28 43 ? C4 41 78 28 4B ? C4 41 78 28 53 ? C4 41 78 28 5B
            
            // Group (animated scalar, value (8,10)/rate (9)/target (11))
            case 8: float SpeedStart; break;
            case 9: float SpeedIncreaseRate; break;
            case 10: Vec3 SpeedStartRangeRand; break; // Same as Prop8, randomized between min-max (Vec3)
            case 11: float SpeedMax; break;
            
            case 12: float Value; break;
            case 13: byte NoTrackingTarget; break;
            case 14: float Value; break;
            case 16: byte BoolValue; break;
            case 17: float Value; break;
            case 18: byte BoolValue; break;
            case 19: byte BoolValue; break;
            case 20: byte BoolValue; break;
            case 21: int EidId; break;
            case 22: int UnkType; break; // TargetType?
            case 24: byte UnkType; break; // passed to a3 in ref: 48 89 5C 24 ? 48 89 74 24 ? 55 57 41 55 41 56 41 57 48 8B EC 48 83 EC ? 48 8B 05 ? ? ? ? 48 33 C4 48 89 45 ? C5 FB 10 05
            case 26: int OperationGroupId; break;
            case 27: int VFXAudioId; break;
            case 28: int Value; break;
            case 29: int Value; break;
            case 30: byte BoolValue; break;
            case 31: float VFXScale; break;
            case 32: float Value; break; // May be length 4 or 12
            case 35: float ProjectileDurationSecond; break;
            case 36: Vec3 ProjectileRandDurationMinMax; break;
            case 37: int OperationGroupId; break; // ref: 8B 93 ? ? ? ? 85 D2 74 ? 48 8B 4B ? E8 ? ? ? ? 83 A3 ? ? ? ? ? 83 A3 ? ? ? ? ? 83 A3 & more (op 3771)
            case 38: byte BoolValue; break;
            case 39: int OperationGroupId; break; // ref: 44 8B 49 ? 33 F6 48 8B D9 45 85 C9 0F 84 ? ? ? ? 48 8B 51 ? 48 8D 05 ? ? ? ? C5 FB 10 05 ? ? ? ? 48 89 44 24 ? 48 8D 4C 24 ? 8B 05 ? ? ? ? 8B BA
            case 41: int AttackParamId; break;
            
            case 42: float Value; break; // These three are as a group
            case 43: float Rate; break; // Speed
            case 44: float Target; break;
            
            case 45: int Type; break; // 41 8B 88 ? ? ? ? 85 C9 0F 84
            case 46: float Value; break;
            case 47: float Value; break;
            case 48: float Value; break;
            case 49: float Value; break;
            case 52: Vec3 Value; break;
            case 53: Vec3 Value; break;
            case 54: Vec3 Value; break;
            case 55: Vec3 Value; break;
            case 56: Vec3 Value; break;
            case 57: Vec3 Value; break;
            case 58: Vec3 Value; break;
            case 59: Vec3 Value; break;
            case 60: Vec3 Value; break;
            case 61: Vec3 Value; break;
            case 62: Vec3 Value; break;
            case 63: Vec3 Value; break;
            case 64: Vec3 Value; break;
            case 65: int Value; break; // May be length 4 or 12
            case 66: float Value; break;
            case 68: int Value; break;
            case 69: int Value; break;
            case 70: float Value; break;
            case 71: float Value; break;
            case 72: Vec3 Value; break;
            
            // In context of operation 51:
            // - 0 = ?
            // - 1 = Targeted Actor
            // - 2 = Source Body Part (Eid Id, specified by Prop 81)
            // - 3 = Source Position (Center)
            // - 4 = ?
            // - 5 = Layout Instance ID (specified by Prop 1458)
            // - 6 = ? (prop 84 is used?)
            // - 7 = ? (Targeted Actor but with a twist)
            case 73: int TargetType; break;
            case 74: float Value; break;
            case 75: int Value; break;
            case 76: int Value; break;
            case 77: int Value; break;
            case 78: int Value; break;
            case 79: int Value; break;
            case 80: int Value; break;
            case 81: uint EidId; break; // ref: 8B 97 ? ? ? ? 4C 8D 45 ? 48 8B C8
            case 89: int VfxAudioId; break; // ref: 44 8B 47 ? 44 8A 67
            case 90: byte BoolValue; break; // Whether to use property 91
            case 91: int Value; break; // MotionLayerSetId maybe? not sure
            case 93: float Value; break;
            case 95: int OnTargetHitOperationGroupIdCallback; break;
            case 96: int OperationGroupId; break; // ref: E8 ? ? ? ? 83 A3 ? ? ? ? ? 83 A3 ? ? ? ? ? C6 83 ? ? ? ? ? EB
            case 97: int Value; break;
            case 98: int Value; break;
            case 99: int Value; break;
            case 102: int OperationGroupId; break; // ref: 48 89 5C 24 ? 48 89 74 24 ? 57 48 83 EC ? 40 8A FA 48 8B D9 8B 91
            case 105: int VFXAudioId; break; // ref: 44 8B 81 ? ? ? ? 48 8B F9 45 85 C0 74
            case 109: int Value; break;
            case 110: int OperationGroupId; break;
            case 114: byte BoolValue; break;
            case 117: float Value; break;
            case 129: float Value; break;
            case 134: int Value; break;
            case 136: int Value; break;
            case 147: int MagicId; break; // ref: 44 8B 41 ? 8B 89
            case 148: int MagicId; break; // ref: 44 8B 43 ? 48 8B 53 ? 48 8D 4C 24
            case 149: int MagicId; break; // ref: 44 8B 43 ? EB ? 3B 4B
            case 150: int Value; break;
            // case 172 May be length 4 or 12
            case 187: int Value; break;
            case 997: float Value; break;
            case 1025: byte Value; break;
            case 1026: byte Value; break;
            case 1123: byte BoolValue; break;
            case 1269: int LayoutInstanceId; break; // ref: 8B 93 ? ? ? ? 41 8B FE
            case 1231: int Value; break;
            case 1232: int Value; break;
            case 1379: float ProjectileDuration; break; // Same as 35, but DifficultyLevel->Unk11 * this
            case 1432: int Value; break;
            case 1458: int LayoutInstanceId; break;
            case 1484: float Value; break; // May be length 4 or 12
            case 1490: byte Value; break;
            case 1503: int OperationGroupId; break; // ref: E8 ? ? ? ? 48 8B 0D ? ? ? ? 48 8D 54 24 ? E8 ? ? ? ? 89 73
            case 1686: float Value; break;
            case 1688: float Value; break;
            case 1791: int Value; break;
            case 1793: float Value; break;
            case 1807: Vec3 Value; break;
            case 1833: int OperationGroupId; break; // 8B 97 ? ? ? ? 85 D2 74 ? 48 8B 4F ? E8 ? ? ? ? 83 A7
            case 1957: byte BoolValue; break;
            case 1994: byte Value; break;
            case 1997: Vec3 Value; break;
            case 1999: float Angle; break; // May be length 4 or 12
            case 2000: float Angle; break;
            case 2060: float Value; break;
            case 2061: uint Value; break;
            case 2062: uint Value; break;
            case 2063: uint Value; break;
            case 2064: uint Value; break;
            case 2065: uint Value; break;
            case 2066: uint Value; break;
            case 2067: uint Value; break;
            case 2068: uint Value; break;
            case 2069: uint Value; break;
            case 2211: float UnkDistance; break; // C5 FA 10 8F ? ? ? ? C5 F8 2F C8 0F 83 ? ? ? ? 48 8D 77
            case 2227: byte BoolValue; break;
            case 2259: byte Value; break;
            case 2260: byte Value; break;
            case 2319: int Value; break;
            case 2351: float Value; break; // May be length 4 or 12
            case 2359: byte BoolValue; break;
            case 2396: int LayoutInstanceId; break;
            case 2413: int Value; break;
            case 2414: int Value; break;
            case 2430: Vec3 Rotation; break;
            case 2528: int Value; break;
            case 2529: int Value; break;
            case 2593: float Value; break;
            case 2575: int Value; break;
            case 2604: byte Value; break;
            case 2672: byte Value; break;
            case 2798: int Value; break;
            case 2856: byte BoolValue; break;
            case 2857: float Value; break;
            case 2906: byte Value; break;
            case 3078: int Value; break;
            case 3079: int Value; break;
            case 3171: float Value; break;
            case 3172: float Value; break;
            case 3362: float Value; break;
            case 3363: int Value; break;
            case 3434: int Value; break;
            case 3440: int OperationGroupId; break;
            case 3441: int OperationGroupId; break;
            case 3497: Vec3 Value; break;
            case 3498: Vec3 Value; break;
            case 3544: int EidId; break;
            case 3606: byte BoolValue; break;
            case 3608: int OperationGroupId; break;
            case 3609: int OperationGroupId; break;
            case 3658: byte Value; break;
            case 3659: int Value; break;
            case 3691: int OperationGroupId; break;
            case 3692: int OperationGroupId; break;
            case 3693: int OperationGroupId; break;
            case 3721: byte BoolValue; break;
            case 3722: int EidId; break;
            case 3785: int Value; break;
            case 3791: int Value; break;
            case 3802: int Value; break;
            case 3848: uint CameraFCurveId; break; // ref: 8B 53 ? 48 8B C8 E8 ? ? ? ? 4C 8B C0 48 85 C0 74 ? 48 83 38 ? 7C ? 48 8B C8 E8 ? ? ? ? 48 85 C0 74 ? 49 83 38 ? 7C ? 49 8B C8 E8 ? ? ? ? EB ? 48 8B C7
            case 3850: uint CameraFCurveId; break; // ref: 8B 53 ? C4 C1 78 28 D9
            case 3856: uint CameraFCurveId; break; // ref: 8B 53 ? 48 8B C8 E8 ? ? ? ? 4C 8B C0 48 85 C0 74 ? 48 83 38 ? 7C ? 48 8B C8 E8 ? ? ? ? 48 85 C0 74 ? 49 83 38 ? 7C ? 49 8B C8 E8 ? ? ? ? 48 8B F8
            case 3938: int LayoutInstanceId; break;
            case 3961: int Value; break;
            case 3962: int Value; break;
            case 3681: byte Value; break;
            case 3872: byte Value; break;
            case 3906: int Value; break;
            case 3907: float Value; break;
            case 3970: byte Value; break;
            case 4002: int EidId; break;
            case 4007: float Value; break;
            case 4008: float Time; break; // ref: C5 FA 10 61 ? C5 FA 10 2D
            case 4010: float Value; break;
            case 4011: int Value; break;
            case 4014: Vec3 Value; break;
            case 4101: float Value; break; // ref: C5 BA 58 77
            case 4102: float Value; break; // ref: C5 BA 58 77
            case 4107: int Value; break;
            case 4128: byte TargetTypeMaybe; break;
            case 4131: int Value; break;
            case 4132: int Value; break;
            case 4243: byte BoolValue; break;
            case 4278: int Value; break;
            case 4279: int Value; break;
            case 4327: int Value; break;
            case 4343: int Value; break;
            case 4387: byte BoolValue; break;
            case 4402: int OperationGroupId; break;
            case 4427: byte Value; break;
            case 4436: int Value; break;
            case 4447: uint Value; break;
            case 4509: byte Value; break;
            case 4774: int OperationGroupId; break;
            case 4785: byte BoolValue; break;
            case 4829: byte Value; break;
            case 4845: int Value; break;
            
            case 4846: int Value; break; // Group of 3 - ref: 48 83 C1 ? E8 ? ? ? ? F6 43 ? ? 0F 85
            case 4847: int Rate; break;
            case 4848: int Target; break;
            
            case 5101: byte Value; break;
            case 5125: byte Value; break;
            case 5274: int CommandId; break;
            case 5275: int CommandId; break;
            case 5276: int SkillUpgradeLevel; break; // ref: 3B 46 ? B9
            case 5312: byte Value; break;
            case 5644: Vec3 Value; break;
            case 5671: int Value; break;
            case 5685: int Value; break;
            case 5838: float Value; break;
            case 5959: Vec3 Color; break;
            case 5989: int Value; break;
            case 6056: byte BoolValue; break;
            case 6107: int OperationGroupId; break;
            case 6179: int Value; break;
            case 6287: float Value; break;
            case 6299: int Value; break;
            case 6339: byte Value; break;
            case 6340: byte Value; break;
            case 6376: byte Value; break;
            case 6383: byte BoolValue; break;
            case 6454: byte Value; break;
            case 6459: byte Value; break;
            case 6471: int Value; break;
            case 6474: int OperationGroupId; break; // ref: 8B 54 9E ? E8 ? ? ? ? 48 8B 5C 24
            case 6475: int OperationGroupId; break; // ref: 8B 54 9E ? E8 ? ? ? ? 48 8B 5C 24
            case 6471: int Value; break;
            case 6515: int OperationGroupId; break; // ref: 8B 93 ? ? ? ? 85 D2 74 ? 48 8B 4B ? E8 ? ? ? ? 83 A3 ? ? ? ? ? C6 83
            case 6516: int OperationGroupId; break; // ref: 8B 93 ? ? ? ? 85 D2 74 ? 48 8B 4B ? E8 ? ? ? ? 83 A3 ? ? ? ? ? EB
            case 6596: byte BoolValue; break;
            case 6600: float Value; break;
            case 6775: Vec3 MinMaxRange; break; // same as prop 9, randomized between range min/max (Vec3)
            case 6776: byte BoolValue; break;
            case 6800: int Value; break;
            case 6801: int Value; break;
            case 6822: int Value; break;
            case 6825: byte BoolValue; break;
            case 6826: byte BoolValue; break;
            case 6831: float Value; break;
            case 6913: int Value; break;
            case 6975: int Value; break;
            case 6988: byte BoolValue; break;
            case 7028: byte Value; break;
            case 7037: float Value; break;
            case 7121: byte Value; break;
            case 7428: byte Value; break;
            case 7429: byte Value; break;
            case 7430: byte Value; break;
            case 7585: int Value; break;
            case 7586: int Value; break;
            case 7587: int Value; break;
            case 7588: int Value; break;
            case 7791: int Value; break;
            case 7799: byte BoolValue; break;
            case 7807: byte Value; break;
            case 7809: int Value; break;
            case 7811: byte BoolValue; break;
            case 7812: int Value; break;
            case 7813: byte BoolValue; break;
            default:
                Printf("Unsupported property type %d for operation %d\n", PropertyType, OperationType_);  
                break; 
        }
    } Data;
} Property <read=Str("Type: %s", EnumToString(PropertyType) == "" ? Str("%d", PropertyType) : EnumToString(PropertyType)), optimize=false, bgcolor=0x006688,
                comment="Sets an operation's property to the specified value">;

typedef struct
{
    int NumTotalProperties <comment="Across all operations">;
    local int op = 0;
    while (op < NumTotalProperties)
    {
        struct
        {
            // Appears to actually be some sort of engine type
            // Different class/object is initiated depending on this
            OperationType OperationType_;
            if (EnumToString(OperationType_) == "")
                Printf("Unrecognized operation %d\n", OperationType_);
                
            int PropertyCount;
            Property Property_[PropertyCount];
        } Operation <read=Str("Type: %s, Count: %d", EnumToString(OperationType_) == "" ? Str("%d", OperationType_) : EnumToString(OperationType_), PropertyCount),
            comment="Each operation does something different and supports a specified set of properties">;
        
        op += Operation.PropertyCount;
    }
} OperationList <bgcolor=cDkGreen, comment="There can only be up to 32 operations (fixed array)">;

typedef struct
{
    uint Id;
    int OperationListOffset <fgcolor=cRed, format=hex>;
    int OperationListSize <comment="Size of the struct specified by DataOffset", format=hex>;
    
    FSeek(startof(this) + OperationListOffset);
    OperationList OperationList_;
} OperationGroup <read=Str("ID: %d", Id), bgcolor=cGreen>;

typedef struct
{
    float field_0x00;
    if (MainHeader.Version >= 5)
        int Unk;
    
    struct
    {
        int OperationGroupCount;
        
        for (local int j = 0; j < OperationGroupCount; j++)
        {
            FSeek(startof(this) + 4 + (j * 0x0C));
            OperationGroup OperationGroup_ <bgcolor=cGreen>;
        }
    } OperationGroupList;
} OperationGroups;
       
typedef struct
{
    uint MagicId <fgcolor=cPurple, comment="Referenced by chara timelines or SummonMode">;
    int OperationGroupsOffset <fgcolor=cRed, format=hex>;
    int OperationGroupsDataSize <comment="Size of the struct specified by OperationGroupsOffset", format=hex>;
    
    FSeek(startof(this) + OperationGroupsOffset);
    OperationGroups OperationGroups_;
} Magic;
                     
struct
{
    struct
    {
        int Version;
        int NumSections;
    } MainHeader <bgcolor=cPurple>;
    
    // Note: The game does not use NumSections (other than check for not zero)
    // or even seem to split this 'sub-header' into multiple sections
    // We do here, for convenience.
    // Section 1 MUST exist as per code. Direct indexing
    struct
    {
        int Index;
        int Offset <format=hex, fgcolor=cRed>;
        int Size <format=hex>;
    } Sections[MainHeader.NumSections] <bgcolor=cDkPurple>;

    FSeek(startof(Sections[0]) + Sections[0].Offset);
    struct
    {
        int EntryCount <fgcolor=cGreen>;
        for (local int i = 0; i < EntryCount; i++)
        {
            FSeek(startof(EntryCount) + (i * 0x0C) + 4);
            Magic Magic_ <read=Str("Magic ID: %d", MagicId), bgcolor=cBlue>;
        }
    } MainSectionData <open=true>;
    
    FSeek(startof(Sections[1]) + Sections[1].Offset);
    byte Section1Data[Sections[1].Size];
} MagicFile <open=true>;
