//------------------------------------------------
//--- 010 Editor v15.0 Binary Template
//
//      File: Final Fantasy XVI UI Binary
//   Authors: AlexCup, Nenkai
//   Version: 
//   Purpose: 
//  Category: UI
// File Mask: *.uib
//  ID Bytes: 55 49 42 00
//   History: 
//------------------------------------------------

const uint64 Sky_400<hidden=true> = 0xF8BD38;
const uint64 Sky_500<hidden=true> = 0xE9A50E;
const uint64 Sky_700<hidden=true> = 0xC78402;
const uint64 Sky_800<hidden=true> = 0x855907;
const uint64 Sky_900<hidden=true> = 0x6E4A0C;

const uint64 Teal_400<hidden=true> = 0xA6B814;
const uint64 Teal_500<hidden=true> = 0x88940D;
const uint64 Teal_700<hidden=true> = 0x6E760F;
const uint64 Teal_800<hidden=true> = 0x595E11;
const uint64 Teal_900<hidden=true> = 0x4A4E13;

const uint64 Green_400<hidden=true> = 0x5EC522;
const uint64 Green_500<hidden=true> = 0x5EC522;
const uint64 Green_700<hidden=true> = 0x518D2D;
const uint64 Green_800<hidden=true> = 0x346516;
const uint64 Green_900<hidden=true> = 0x42652C;

const uint64 Amber_400<hidden=true> = 0x24BFFB;
const uint64 Amber_500<hidden=true> = 0x0B9EF5;
const uint64 Amber_600<hidden=true> = 0x0677D9;
const uint64 Amber_700<hidden=true> = 0x0953B4;
const uint64 Amber_800<hidden=true> = 0x0E4092;
const uint64 Amber_900<hidden=true> = 0x0F3578;

const uint64 Red_400<hidden=true> = 0x7171F8;
const uint64 Red_500<hidden=true> = 0x4444EF;
const uint64 Red_600<hidden=true> = 0x2626DC;
const uint64 Red_700<hidden=true> = 0x1C1CB9;
const uint64 Red_800<hidden=true> = 0x1B1B99;
const uint64 Red_900<hidden=true> = 0x1D1D7F;

struct NodeList;
struct BezierNode;
struct AssetEntry;

typedef struct TColor{
    ubyte r;
    ubyte g;
    ubyte b;
    ubyte a;
    
    local uint full_color<format=hex> = a;
    full_color = full_color << 8;
    full_color |= b;
    full_color = full_color << 8;
    full_color |= g;
    full_color = full_color << 8;
    full_color |= r;
} Color <bgcolor=(this.full_color & 0xFFFFFF), read=Str("r%u, g%u, b%u, a%u", this.r, this.g, this.b, this.a)>;

typedef int OffsetT <fgcolor=cRed, format=hex>;

typedef struct TPoint{
    int x, y;
} Point <read=Str("%d, %d", this.x, this.y)>;

typedef struct TVector2{
    float x, y;
} Vector2 <read = Str("%f, %f", this.x, this.y)>;

enum BlendMode
{
    kNormal = 0,
    kDarken = 1,
    kMultiply = 2,
    kColorBurn = 3,
    kLinearBurn = 4,
    kLighten = 5,
    kScreen = 6,
    kColorDodge = 7,
    kLinearDodge = 8,
    kOverlay = 9,
    kSoftLight = 10,
    kHardLight = 11,
    kVividLight = 12,
    kLinearLight = 13,
    kHdrBlend = 14,
    kHdrLowBlend = 15,
    kHdrHighBlend = 16,
};

enum LayerEffect{
    kColorFilter,
    kChromaticAberration,
    kBlur,
    kDropShadow,
    kGlow,
    kRadialBlur,
    kBackgroundBlur,
    kAlphaMask,
    kImageMask,
    kAntiAliasing,
};

enum NodeType
{
    kLayerNode = 1,
    kImageNode = 2,
    kTextNode = 3,
    kNinegridNode = 4,
    kCounterNode = 5,
    kRectNode = 6,
    kEllipseNode = 7,
    kBezier = 8,
    kCollisionNode = 9,
    kReferenceNode = 10,
    kEffectNode = 11,
    kModelNode = 12,
    kMaskNode = 13
};

typedef struct
{
    OffsetT ResourceInfoOffset;
    int Unused;
    int field_0x08;
    byte pad[0x20];
    
    FSeek(startof(this) + ResourceInfoOffset);
    AssetEntry ResourceInfo;
    
    FSeek(startof(this) + 0x2C);
} TextureAsset <optimize=false>;  
    
typedef struct TNodeStruct_0
{
    int field_0x0; // Maybe timeline item index
    OffsetT NameOffset;
    int TimelineElementType; // Maybe timeline item type + flags
    int FrameStart <bgcolor=cLtRed>;
    int NumFrames <fgcolor=0x8affff>;
    int TargetIndex <fgcolor=cGreen, comment="Index of group member this item affects">;
    ubyte bool_0;
    ubyte bool_1;
    byte pad_[2];
    OffsetT DataOffset <bgcolor=cDkRed>;
    
    FSeek(startof(this) + DataOffset);
    
    struct 
    {
        int TimelineElementType;
        byte pad[0x2C]<bgcolor=cGray>;

        switch(TimelineElementType)
        {
            // 5009: Likely for keyframes
            // 5027: For beziers     
              
            // Handled at
            // 48 8B C4 48 89 58 ? 48 89 70 ? 48 89 78 ? 55 41 54 41 55 41 56 41 57 48 8D 68 ? 48 81 EC ? ? ? ? 48 8B 05 ? ? ? ? 48 33 C4 48 89 45 ? 8B 42
            
            // Anything >= 5031 is handled at
            // 48 8B C4 48 89 58 ? 48 89 70 ? 48 89 78 ? 55 41 56 41 57 48 8D 68 ? 48 81 EC ? ? ? ? 48 8B 05 ? ? ? ? 48 33 C4 48 89 45 ? 8B 42
            
            case 5002: {
                int Field_0x30;
                byte pad2[0x40];
                int Field_0x74;
                int Field_0x78;
                break;
            }
            case 5003: {
                int Field_0x30;
                byte pad2[0x40];
                int Field_0x74;
                int Field_0x78;
                break;
            }
            case 5004: {
                int Field_0x30;
                byte pad2[0x40];
                float Field_0x74;
                float Field_0x78;
                break;
            }
            case 5005: {
                int Field_0x30;
                byte pad2[0x40];
                float Field_0x74;
                break;
            }
            case 5007: {
                int Field_0x30;
                byte pad2[0x40];
                byte Field_0x74;
                byte Field_0x75;
                byte Field_0x76;
                byte pad3;
                break;
            }
            case 5009: {
                int Field_0x30;
                byte pad2[0x40];
                float Field_0x74;
                break;   
            }
            case 5017: {
                int Field_0x30;
                byte pad2[0x40];
                byte Field_0x74;
                byte Field_0x75;
                byte Field_0x76;
                byte pad3;
                break;   
            }
            case 5028: {
                OffsetT StrOffset;
                byte pad2[0x40];
                
                FSeek(startof(this) + StrOffset);
                string Str;
                break;   
            }
            case 5031: {
               byte pad2[0x40];
               break;
            }
            case 5034: {
               byte pad2[0x20];
               int Field_0x50;
               float Field_0x54;
               byte pad3[0x20];
               break;
            }
            case 5035: {
               byte pad2[0x20];
               int Field_0x50;
               float Field_0x54;
               byte pad3[0x20];
               break;
            }
            case 5050: {
               int Field_0x30;
               byte pad2[0x1C];
               int Field_0x50;
               float Field_0x54;
               byte pad3[0x20];
               break;
            }
            case 5051: {
               int Field_0x30;
               byte pad2[0x1C];
               int Field_0x50;
               float Field_0x54;
               byte pad3[0x20];
               break;
            }
            default:
            {
                Printf("Unimplemented timeline element type %d\n", TimelineElementType);
                break;
            }
        }
    } TimelineElement <bgcolor=cDkGreen>;
    
    FSeek(startof(this) + NameOffset);
    string Name;
    
    FSeek(startof(this) + 0x20);
} MemberStruct_0<bgcolor=cRed, name = Str("%d: Item %d ", this.TimelineElementType, this.TargetIndex)>;

typedef struct TNodeStruct_1(int count)
{
    local int cnt <hidden=true> = count;
    OffsetT Offsets[count]<bgcolor=Teal_400>;
    
    local int i <hidden=true>;
    for( i = 0 ; i < count ; i++ )
    {
        FSeek( startof(Offsets) + Offsets[i] );
        struct
        {
            int Type;
            byte pad[0x24];
            
            // 40 53 55 56 57 41 54 41 55 41 56 41 57 48 83 EC ? 48 8B 05 ? ? ? ? 48 33 C4 48 89 44 24 ? 83 3A
            switch (Type)
            {
                case 4001: // Setup image?
                    {
                        OffsetT name_offset<bgcolor=cDkRed>;
                        FSeek(startof(this) + name_offset);
                        string name<bgcolor=cNone>;
                        FSeek(startof(this) + 0x2C);
                    }
                    break;
                    
                case 4002: // Start? - E8 ? ? ? ? EB ? 49 63 50
                    break;
                    
                default:
                    Printf("Unresolved timeline setup elem %d\n", Type);
                    break;
            }

        } Member<name = (exists(this.name) ? this.name : ""), read=Str("Type: %d", this.Type)>;
    }
} TimelineTarget <bgcolor=cPurple, read=Str("Members: %d", this.cnt)>;

typedef struct TTimelineMember
{
    OffsetT NameOffset;
    uint flags <format=hex>;
    
    // This is its own structure as per
    // 40 53 55 56 57 41 54 41 55 41 56 41 57 48 83 EC ? 48 8B 05 ? ? ? ? 48 33 C4 48 89 44 24 ? 83 3A
    struct
    {
        int Type;
        OffsetT ElementsOffset;
        int ElementCount <fgcolor=cGreen>;
        OffsetT UnusedOffset_0x0C;
        int UnusedCount_0x10 <fgcolor=cGreen>;
        OffsetT TargetsOffset;
        int TargetCount <fgcolor=cGreen>;
        int FrameCount;
        int Field_0x28;
        
        if (ElementCount)
        {
            FSeek(startof(this) + ElementsOffset);
            MemberStruct_0 TimelineElements[ElementCount]<optimize=false>;
        }
        
        FSeek(startof(this) + UnusedOffset_0x0C);
        struct
        {
            int Index;
            OffsetT UnkOffset;
            int UnkCount <fgcolor=cGreen>;
        } UnusedUnk_0x0C[UnusedCount_0x10]<bgcolor=cGreen>;
        
        FSeek(startof(this) + TargetsOffset);
        TimelineTarget TimelineTargets(TargetCount);
        

    } TimelineInfo;
    FSeek(startof(this) + 0x2C);
    
    int Field_0x2C;
    OffsetT StrOffset_0x30 <fgcolor=cRed>;
    OffsetT AssetsOffset <fgcolor=cRed>;
    int Field_0x38;
    OffsetT StrOffset_0x3C <fgcolor=cRed>;
    int Field_0x40;
    byte _pad[0x1C];
    
    FSeek(startof(this) + NameOffset);
    string Name <bgcolor=Sky_500>;
    
    FSeek(startof(this) + StrOffset_0x30);
    string Name0x30;
    
    FSeek(startof(this) + AssetsOffset);
    AssetEntry UiAsset;
    
    FSeek(startof(this) + StrOffset_0x3C);
    string Name0x3C;

    FSeek(startof(this) + 0x60);
} UIComponentTimeline <name = this.Name>;

typedef struct TNodeDataBase{
    int field_0x00;
    int field_0x04;
    Color color;
    Color field_0x0C;
    float field_0x10;
    int field_0x14;
    int field_0x18;
    byte Bool_0x19;
    byte Bool_0x1A;
    byte Bool_0x1B;
    byte Bool_0x1C;
    int field_0x20;
    int field_0x24;
    int field_0x28;
    int field_0x2C;
    int pad[4];
} NodeDataBase;

typedef struct TLayerNode // 1
{
    NodeDataBase Base;
    byte pad[0x20] <fgcolor=cDkGray>;
} LayerNode;

typedef struct TImageNode // 2
{
    NodeDataBase Base;
    OffsetT TextureInfosOffset;
    int TextureInfoCount <fgcolor=cGreen>;
    byte _pad[0x20];
    int Type_0x68; // Type0-3
    int Field_0x6C;
    int Field_0x70;
    int Field_0x74;
    byte _pad2[0x1C];
    
    FSeek(startof(this) + TextureInfosOffset);
    TextureAsset TextureAssets[TextureInfoCount];  
} ImageNode;

typedef struct TTextNode // 3
{
    NodeDataBase Base;
    int UiKeyId <comment="from 'ui' nex table - may be set manually externally?">;
    int UnkStrOffset0x44 <format=hex, fgcolor=cRed>;
    int FontSize;
    byte Byte0x4C;   // Sometimes 1 in some uib, not clear what it does
    byte Byte0x4D;
    byte Byte0x4E;
    byte pad0x4F;
    int spacing;
    int line_height;
    enum <int>
    {
        kVerticalTextAlignment_Top = 0,
        kVerticalTextAlignment_Center = 1,
        kVerticalTextAlignment_Bottom = 2,
        kVerticalTextAlignment_StretchToFit = 3,
    } vertical_alignment;
    
    enum <int> 
    {
         kHorizontalTextAlignment_Left = 0,
         kHorizontalTextAlignment_Center = 1,
         kHorizontalTextAlignment_Right = 2,
         kHorizontalTextAlignment_StretchToFit = 3,
         kHorizontalTextAlignment_Unk4 = 4,
    } horizontal_alignment;
    enum <int>
    {
        Text0x60_Type0 = 0,
        Text0x60_Type1 = 1,
        Text0x60_Type2 = 2,
        Text0x60_Type3 = 3,
    } UnkType_0x60;
    byte pad[0x0C];
    int Field_0x70;
    byte pad2[0x0C];

    FSeek(startof(Base) + UnkStrOffset0x44);
    string unk_str;
    
    FSeek(startof(Base) + 0x80);
} TextNode;

typedef struct TNinegridNode // 4
{
    NodeDataBase Base;
    OffsetT TextureInfosOffset;
    int TextureInfoCount <fgcolor=cGreen>;
    byte _pad[0x20];
    int Type_0x68; // Type0-3
    int Field_0x6C;
    int Field_0x70;
    int Field_0x74;
    int Field_0x78; // Type0-3
    int Field_0x7C;
    byte _pad2[0x08];
    
    FSeek(startof(this) + TextureInfosOffset);
    
    struct
    {
        OffsetT ResourceInfoOffset;
        int Unused;
        int field_0x08;
        byte pad[0x20];
        
        FSeek(startof(this) + ResourceInfoOffset);
        AssetEntry ResourceInfo;
    } TextureInfos;  
} NinegridNode;

typedef struct TCounterNode
{
    NodeDataBase Base;
    OffsetT TextureInfosOffset;
    int TextureInfoCount <fgcolor=cGreen>;
    byte _pad[0x20];
    OffsetT UnkStrOffset0x68;
    OffsetT UnkStrOffset0x6C;
    int Field_0x70;
    int Field_0x74;
    int Field_0x78;
    int Type_0x7C; // Type0-3
    int Field_0x80;
    byte _pad2[0x08];
    
    FSeek(startof(this) + TextureInfosOffset);
    TextureAsset TextureAsset_;
    
    FSeek(startof(this) + UnkStrOffset0x68);
    string Str0x68;
    
    FSeek(startof(this) + UnkStrOffset0x6C);
    string Str0x6C;
} CounterNode;

typedef struct TRectNode // 6
{
    NodeDataBase Base;
    int Field_0x40;
    int Field_0x44;
    int Field_0x48;
    int Field_0x4C;
    byte pad[0x10];
} RectNode;

typedef struct TEllipseNode // 7
{
    NodeDataBase Base;
    int Field_0x40;
    float Field_0x44;
    int Field_0x48;
    int Field_0x4C;
    OffsetT TextureInfosOffset;
    int TextureInfoCount <fgcolor=cGreen>;
    byte _pad2[0x08];
    
    FSeek(startof(this) + TextureInfosOffset);
    struct
    {
        OffsetT ResourceInfoOffset;
        int Unused;
        int field_0x08;
        byte pad[0x20];
        
        FSeek(startof(this) + ResourceInfoOffset);
        AssetEntry ResourceInfo;
    } TextureInfos;
} EllipseNode;

typedef struct TBezierNode
{
    Point origin;
    Point handle_a;
    Point handle_b;
    float Field_0x18;
    int Field_0x1C;
    byte padding[0x18];
} BezierNode <bgcolor=cDkBlue, read=BezierNodeRead>;

string BezierNodeRead(BezierNode& input)
{
    return Str("Origin: %d, %d", input.origin.x, input.origin.y);
}

typedef struct TBezier{
    NodeDataBase Base;
    int Field_0x40;
    int Field_0x44;
    int Type_0x48; // 0-2
    int Type_0x4C; // 0-2
    int Type_0x50; // 0-2
    int Field_0x54;
    float Field_0x58;
    float Field_0x5C;
    float Field_0x60;
    byte Field_0x64;
    byte Field_0x65;
    byte pad[2];
    int Field_0x68; // Type 0-1
    float Field_0x6C;
    float Field_0x70;
    float Field_0x74;
    float Field_0x78;
    float Field_0x7C;
    OffsetT NodesOffset;
    int NodesCount <fgcolor=cGreen>;

    FSeek(startof(this) + NodesOffset);
    BezierNode Nodes[NodesCount];
} Bezier;

typedef struct TCollisionNode
{
    NodeDataBase Base;
    int Unk_0x40;
    byte pad[0x1C];
} CollisionNode;

typedef struct TReferenceNode {
    NodeDataBase Base;
    int Unused0x40;
    int Field_0x44;
    int Field_0x48;
    int Field_0x4C;
    int Field_0x50;
    int Field_0x54;
    int Field_0x58;
    int Field_0x5C;
    int Field_0x60;
    int Field_0x64;
    int Field_0x68;
    int Unused_0x6C;
    int Field_0x70;
    int Field_0x74;
    int Field_0x78;
    int Field_0x7C;
    int Field_0x80;
    int Field_0x84;
    int Type_0x88; // Type0-3
    int Type_0x8C; // Type0-4
    byte pad[0x18];
} ReferenceNode;

typedef struct TEffectNode
{
    NodeDataBase Base;
    byte _pad[0x20];
} EffectNode;

typedef struct TMaskNode // 13
{
    NodeDataBase Base;
    OffsetT TextureInfosOffset;
    int TextureInfoCount <fgcolor=cGreen>;
    byte Pad[0x40];
    
    FSeek(startof(this) + TextureInfosOffset);
    TextureAsset TextureAssets[TextureInfoCount];  
} MaskNode;

typedef struct TNode
{
    // 48 8B C4 48 89 58 ? 55 56 57 41 54 41 55 41 56 41 57 48 8D 68 ? 48 81 EC ? ? ? ? C5 F8 29 70 ? C5 F8 29 78 ? 48 8B 05 ? ? ? ? 48 33 C4 48 89 45 ? 48 8B DA
    
    NodeType Type;
    OffsetT NameOffset <bgcolor=cWhite>;
    Point Origin;
    float Rotation;
    Vector2 Scale;
    Point AnchorPoint;
    int IsAnchored;
    byte pad0[0x1C];
    Point Size;
    int DataOffset <format=hex, fgcolor=cRed>;
    int field_0x50;
    byte pad1[0x1C];
    
    // Yes i know. lots of weird padding.
    // Trust me it's correct though.
    if (Type == kReferenceNode)
    {
        OffsetT ReferenceNameOffset;
        OffsetT ReferenceAssetOffset <bgcolor=cGreen>;
        byte pad2[0x08];
    }
    else if (Type == kTextNode)
    {
        int TextField_0x70;
        byte pad2[0x1C];   
    }
    else if (Type == kLayerNode)
    {
       byte pad2[0x20];
       OffsetT LayerChildrenOffset;
       uint LayerChildCount <bgcolor=cGreen>;
    }
    else if (Type == kEffectNode)
    {
         byte pad2[0x04];
         OffsetT EffectAssetOffset;
         byte pad2_2[0x1C];
    }
    else if (Type == kImageNode || Type == kCounterNode || Type == kNinegridNode)
    {
        byte pad2[0x2C];   
    }
    else if (Type == kRectNode)
    {
        byte pad2[0x20];   
    }
    else if (Type == kEllipseNode)
    {
        byte pad2[0x20];   
    }
    else if (Type == kCollisionNode)
    {
        // Nothing
    }
    else if (Type == kMaskNode)
    {
        byte pad2[0x2C];
        OffsetT MaskUiAssetOffset;
        OffsetT MaskNameUnkOffset;
        byte pad3[0x18];
    }
    else
        Printf("GUINode type %s (%d) not supported\n", EnumToString(Type), Type);
        
    if (Type != kLayerNode && Type != kMaskNode)
        byte pad3[0x20];
    
    FSeek(startof(this) + DataOffset);
    switch(Type)
    {
        case kLayerNode:
            LayerNode LayerNodeData <bgcolor=cPurple, comment="Group of elements">; break;
        case kImageNode:
            ImageNode ImageNodeData <bgcolor=cPurple>; break;
        case kTextNode:
            TextNode TextNodeData <bgcolor=cPurple>; break;  
        case kNinegridNode:
            NinegridNode NinegridNodeData <bgcolor=cPurple>; break;   
        case kCounterNode: // frytext.uib
            CounterNode CounterNodeData <bgcolor=cPurple>; break;  
        case kRectNode:
            RectNode RectNodeData <bgcolor=cPurple>; break;
        case kEllipseNode:
            EllipseNode EllipseNodeData <bgcolor=cPurple>; break;
        case kBezier:
            Bezier BezierData <bgcolor=cPurple>; break;
        case kCollisionNode:
            CollisionNode CollisionNodeData <bgcolor=cPurple>; break;  
        case kReferenceNode:
            ReferenceNode ReferenceNodeData <bgcolor=cPurple, comment="Reference to layer">; break;
        case kEffectNode:
            EffectNode EffectNodeData <bgcolor=cPurple>; break;  
        case kMaskNode:
            MaskNode MaskNodeData <bgcolor=cPurple>; break;
        default:
            break;
    }
        
    FSeek(startof(this) + NameOffset);
    string Name <bgcolor=cWhite>;
    
    if (Type == kLayerNode)
    {
        FSeek(startof(this) + LayerChildrenOffset);
        NodeList LayerChildren(LayerChildCount);
    }
    else if (Type == kReferenceNode)
    {
        FSeek(startof(this) + ReferenceNameOffset);
        string ReferenceName;
        
        FSeek(startof(this) + ReferenceAssetOffset);
        AssetEntry ReferenceAssetEntry;
    }
    else if (Type == kEffectNode)
    {
        FSeek(startof(this) + EffectAssetOffset);
        AssetEntry EffectAssetEntry;
    }
    else if (Type == kMaskNode)
    {
        FSeek(startof(this) + MaskUiAssetOffset);
        AssetEntry MaskAssetEntry;
        
        FSeek(startof(this) + MaskNameUnkOffset);
        string MaskNameUnk;
    }
    
} Node  <name = Str("%s @ %d,%d (%dx%d) ", this.Name, this.Origin.x, this.Origin.y, this.Size.x, this.Size.y), 
            read=EnumToString(this.Type), 
            bgcolor=cDkRed>;

typedef struct TNodeList(uint count){
    local uint cnt<hidden=true> = count;
    OffsetT offsets[count];
    
    local int cpos = FTell();
    local int i<hidden=true>;
    for(i = 0 ; i < count; i++)
    {
        FSeek(startof(this) + offsets[i]);
        Node node<bgcolor=cLtPurple>;
    }
    
    FSeek(cpos);
} NodeList <read=Str("Nodes: %d", this.cnt)>;

typedef struct TLayerProperties
{
    // Mainly read from 48 89 5C 24 ? 55 56 57 41 54 41 55 41 56 41 57 48 8B EC 48 83 EC ? 4C 63 72
    
    // Determines type of layer component
    // 48 8B C4 48 89 58 ? 48 89 70 ? 48 89 78 ? 4C 89 70 ? 55 48 8D 68 ? 48 81 EC ? ? ? ? 48 63 42
    enum 
    {
        kComponentRoot = 1,
        kComponentCustom = 2,
        kComponentButton = 3,
        kComponentCheckBox = 4,
        kComponentRadioButton = 5,
        kComponentTab = 6,
        kComponentSlider = 7,
        kComponentScrollBar = 8,
        kComponentList = 9,
        kComponentListItem = 10,
        kComponentDropdownList = 11,
        kComponentGauge = 12,
        kComponentTextBoard = 13,
        kComponentWindow = 14,
        kComponentBahamutEffect = 15,
    } ComponentType;
    
    int name_offset_offset<format=hex, fgcolor=cRed>;
    int name_count<fgcolor=cGreen>;
    // 74 ? 41 2B C1 74 ? 41 3B C1 75
    enum <int>
    {
        SubType0 = 0,
        SubType1 = 1,
        SubType2 = 2,
    } UnkSubType;
    
    BlendMode BlendMode_;
    uint UnkColor;
    int unknowns_0[1];
    int UnkPercentage0;
    int UnkPercentage1;
    int UnkPercentage2;
    int field_0x28;
    float field_0x2C;
    float field_0x30;
    float field_0x34;
    float field_0x38;
    float field_0x3C;
    float field_0x40;
    float field_0x44;
    float field_0x48;
    int field_0x4C;
    float field_0x50;
    float field_0x54;
    float field_0x58;
    float field_0x5C;
    short field_0x60;
    byte field_0x62;
    byte field_0x63;
    float field_0x64;
    enum <int>
    {
        Unk0x68_Type0 = 0,
        Unk0x68_Type1 = 1,
        Unk0x68_Type2 = 2,
    } Type_0x68;
    float field_0x6C;
    float field_0x70;
    byte field_0x74[4];
    float field_0x78;
    float field_0x7C[4];
    enum <int>
    {
        Unk0x8C_Type0 = 0,
        Unk0x8C_Type1 = 1,
        Unk0x8C_Type2 = 2,
        Unk0x8C_Type3 = 3,
    } Type_0x8C;
    float field_0x90;
    float field_0x94;
    int offset_0x98 <format=hex, fgcolor=cRed>;
    float field_0x9C;
    float field_0xA0;
    float field_0xA4;
    int offset_0xA8 <format=hex, fgcolor=cRed>;
    int count_0xAC <fgcolor=cGreen>;
    int field_0xB0;
    int field_0xB4;
    int field_0xB8;
    float field_0xBC;
    float field_0xC0;
    float field_0xC4;
    float field_0xC8;
    uint field_0xCC;
    float field_0xD0;
    float field_0xD4;
    float field_0xD8;
    float field_0xDC;
    float field_0xE0;
    float field_0xE4;
    float field_0xE8;
    float field_0xEC;
    int field_0xF0;
    int field_0xF4;
    int sub_type_0xF8; // Used if type == 1?
    int field_0xFC; // Used if type == 1?
    int field_0x100;
    int field_0x104;
    
    switch (ComponentType)
    {

        case kComponentRoot:
            int field_0x108; // Type 1-5
            int field_0x10C; // Type 1-5
            byte padding[0x18] <fgcolor=cDkGray>;
            break;
            
        case kComponentTextBoard:
            byte padding[0x20] <fgcolor=cDkGray>;
            break;
            
        case kComponentScrollBar:
            int field_0x108; // Same as 15->0x134?
             byte padding[0x1C] <fgcolor=cDkGray>;
            break;
            
        case kComponentBahamutEffect:
            float Type15_field_0x108;
            float Type15_field_0x10C;
            float Type15_field_0x110;
            float Type15_field_0x114;
            float Type15_field_0x118;
            float Type15_field_0x11C;
            int Type15_field_0x120;
            int Type15_field_0x124;
            int Type15_field_0x128;
            float Type15_field_0x12C;
            float Type15_field_0x130;
            float Type15_field_0x134;
            float Type15_field_0x138;
            float Type15_field_0x13C;
            float Type15_field_0x140;
            float Type15_field_0x144;
            float Type15_field_0x148;
            float Type15_field_0x14C;
            float Type15_field_0x150;
            int Type15_field_0x154;
            int Type15_field_0x158;
            byte padding[0x20];
            break;
            
        default:
            byte padding[0x20] <fgcolor=cDkGray>;
            break;
    }

    local int endPos = FTell();
    struct
    {
        FSeek(startof(ComponentType) + name_offset_offset);
        int str_offset[name_count] <format=hex, fgcolor=cRed>;
    
        local int i = 0;
        for (i = 0; i < name_count; i++)
        {
            FSeek(startof(str_offset) + str_offset[i]);
            struct
            {
                string str;
            } Name <name=str>;
        }
        
        FSeek(startof(str_offset) + (name_count * 4));
    } names <bgcolor=cGray>;
    
    FSeek(startof(ComponentType) + offset_0x98);
    AssetEntry struct_0x98 <bgcolor=cDkRed>;
    
    if(count_0xAC > 0)
    {
        struct
        {
            FSeek(startof(ComponentType) + offset_0xA8);
            int offset_0<fgcolor=cRed, format=hex>;
            int field_1;
            uint field_2 <format=hex>;
            
            byte padding[0x20] <fgcolor=cDkGray>;
            FSeek(startof(offset_0) + offset_0);
            AssetEntry test;
        } struct_0xA8 <bgcolor=cDkPurple>;
    }
    
    
    FSeek(endPos);
} ComponentProperties <bgcolor=cRed>;

typedef struct TGroupEntry{
    uint NameOffset <format=hex, fgcolor=cRed>;
    Point Size;
    uint ComponentPropertiesOffset <format=hex, fgcolor=cRed>;
    OffsetT NodesOffset;
    uint NodeCount <bgcolor=cGreen>;
    OffsetT TimelineMembersOffset;
    uint TimelineMemberCount <bgcolor=cGreen>;
    byte _pad[0x20] <fgcolor=cDkGray>;
    
    FSeek(startof(this) + NameOffset);
    string Name <bgcolor=cPurple>;
    
    FSeek(startof(this) + ComponentPropertiesOffset);
    ComponentProperties ComponentProperties_;
    
    if (NodeCount)
    {
        FSeek(startof(this) + NodesOffset);
        NodeList Nodes(NodeCount);
    }
    
    if (TimelineMemberCount)
    {
        FSeek(startof(this) + TimelineMembersOffset);
        UIComponentTimeline Timeline[TimelineMemberCount] <optimize=false>;
    }
    
    FSeek(startof(NameOffset) + 0x40);
} GroupEntry <name = Str("%s (%dx%d) ", this.Name, this.Size.x, this.Size.y),
                read=GroupRead>;
                
string GroupRead(GroupEntry& input)
{
    local int count = input.NodeCount;
    local string type = EnumToString(input.ComponentProperties_.ComponentType);
    local string blend_mode = EnumToString(input.ComponentProperties_.BlendMode_);
    return Str("[%s] Nodes: %d, Blend Mode: %s", type, count, blend_mode);
}

typedef struct TAssetEntry{
    enum 
    {
        kInvalid,
        kTexture,
        kUi,
        kVfx,
    } Type;
    
    OffsetT TexturePathOffset;
    OffsetT NameInfoOffset;
    byte pad[0x20] <bgcolor=cBlack, fgcolor=cDkGray>;
    
    FSeek(startof(this) + TexturePathOffset);
    string StrData <bgcolor=Amber_700>;
    
    FSeek(startof(this) + NameInfoOffset);
    struct
    {
        int unknown <format=hex>;
        int PartPathOffset <format=hex, fgcolor=cRed>;

        FSeek(startof(this) + PartPathOffset);
        string StrData <bgcolor=Amber_400>;
        
        FSeek(startof(this) + 0x08);
    } NameInfo <read=this.StrData, bgcolor=cLtBlue>;

    FSeek(startof(this) + 0x2C);
} AssetEntry;

typedef struct(int count)
{
    local int cnt = count;
    if (count)
    {
        OffsetT Offsets[count];
        local int i<hidden=true>;
        for(i = 0; i < count; i++)
        {
            FSeek(startof(this) + Offsets[i]);
            AssetEntry DataEntry;
        }
    }
} DataList <read = Str("%d entries", cnt)>;


//////////////////////////////////////////////////
// START
/////////////////////////////////////////////////
struct TUIBHeader
{
    uint Magic<format=hex, comment="'UIB\\0', checked">;
    uint Version<comment="FF16: Version 10 expected">;
    byte reserved[16];
    uint TOCOffset <format=hex>;
    byte _empty_[16];
} Header <bgcolor=cPurple>;

FSeek(startof(Header) + Header.TOCOffset);
struct
{
    OffsetT AssetListOffset;
    OffsetT ComponentsOffset;
    int ComponentCount <fgcolor=cGreen>;
    
    FSeek(startof(UIFileToc) + UIFileToc.AssetListOffset);
    struct TAssetCollection
    {
        OffsetT TextureAssetsOffset;
        int TextureAssetCount <fgcolor=cGreen>;
        OffsetT UIAssetsOffset;
        int UIAssetCount <fgcolor=cGreen>;
        OffsetT VFXAssetsOffset;
        int VFXAssetCount <fgcolor=cGreen>;
        byte _pad[0x1C] <bgcolor=cBlack, fgcolor=cDkGray>;
        
        FSeek(startof(this) + TextureAssetsOffset);
        DataList TextureAssets(TextureAssetCount)<bgcolor=cDkYellow>;
    
        FSeek(startof(this) + UIAssetsOffset);
        DataList UIAssets(UIAssetCount)<bgcolor=cLtGreen>;
    
        FSeek(startof(this) + VFXAssetsOffset);
        DataList VFXAssets(VFXAssetCount)<bgcolor=cLtBlue>;
        
        FSeek(startof(this) + 0x34);
    } Assets;
} UIFileToc <open=true, bgcolor=cRed, size=0x2C>;

FSeek(startof(UIFileToc) + UIFileToc.ComponentsOffset);
local int i = 0;
struct
{
    local int count<hidden=true> = UIFileToc.ComponentCount;
    for (i = 0; i < count; i++)
    {
        FSeek(startof(UIFileToc) + UIFileToc.ComponentsOffset + (i * 0x40));
        GroupEntry Layer <bgcolor=cBlue>;
    }
} Components <open=true, read=Str("Components: %d", this.count)>;
